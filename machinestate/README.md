&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-17 16:44:01  

# 简介
这个库呢, 是协助我理解底层`os`实现细节的库. 差不多十天前吧, 编写了些许的`os`, 并有了一定的理解. 然后这十来天没有弄, 但是却一直思考着. 昨天考完嵌入式之后呢, 又打算来弄弄, 因为下周日就要考操作系统了, 所以还是想提升一下理解的. 一开始刚弄的时候, 没什么认识, 也只是单纯地跟着写写, 然后靠`ai`提升理解. 今天又看了些`linux`相关书籍(当然, 肯定不是全看完的), 里面的思想确实是一脉相承的. 但是回顾上次的教训, 打算需要有比较好的内存, 寄存器可视化的东西, 来抽象模拟一下. 从淘宝搜了搜, 没有合适的东西. 于是又问了问`ai`, 说到了`logisim`. 可是学这个, 又需要拿出来时间去学, 这与我的初心是相违背的. 想了想呢, 有没有`python`库能直接实现呢? 这确实是个好主意. 问了`ai`呢, 发现似乎没有好的库来实现. 只能抽象模拟. 但是怎么抽象模拟呢? 自己写逻辑呗, 让`cpu`内部运行可视化出来. 这些其实都不是关键的, 因为`qemu`中, 各个寄存器的状态都能查看, 内存情况也能查看. 关键的是, 我可以将具体内部细节给实例化出来. 因为`debug`的时候, 只能孤零零地看状态, 而且也只能看状态, 没有任何的自由度可言. 而通过`python`呢, 可以生成一个又一个对象, 来进行抽象模拟, 以达到可控的目的. 为什么选择`python`呢? 还是因为它简单, 而且我写了比较多了, 比较可控一些.  

在此之前呢, 先分析分析状况. 首先呢, 这里没有渲染引擎去绘制, 只能以类的对象的方式来抽象模拟. 但是对于我而言, 这种抽象已经足够了. 由于知识的匮乏, 结构上肯定不是最优的. 后续会慢慢更改, 尽量做到当前结构最优. 另外, 这其实也是为后续渲染引擎的开发而做准备的. 假如我底层已经开发好了渲染引擎, 现在想抽象模拟底层`os`实现细节, 应该如何操作呢? 目前, 我们不需要考虑这些问题, 只需要尽可能地将运行态模拟出来就好了.  

最后呢, 我觉得将计算机的关键术语搞明白, 还是很有必要的. 比如, 字, 字节, 位, 进制转换, 地址空间等等, 这些关键性概念搞清楚. 之前搞清楚过, 但是没有建立良好的心理表征, 导致过了一段时间后再看, 就很容易搞混, 哈哈. 












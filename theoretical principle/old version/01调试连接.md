- 打开调试器
~~~C
x86_64-elf-gdb os.elf
~~~
- 远程连接`QEMU`
~~~C
target remote 127.0.0.1:1234
~~~
- 为`gdb`启用整齐打印
~~~C
enable pretty-printing // 不确定
~~~
- 设置反汇编风格
~~~C
set disassembly-flavor intel
~~~
- 设置体系结构为`16`位实模式(`i8086`)
~~~C
set architecture i8086
~~~
- 停止在启动扇区`0x7c00`
~~~C
exec-until *0x7c00
~~~
- 查看寄存器
~~~C
info registers
~~~
- 查看内存
~~~C
x/16xb 0x7c00
~~~
- 单步执行
~~~C
stepi
~~~
- 继续执行
~~~C
continue
~~~
- 终止执行
~~~C
ctrl c
~~~
- 设置断点
~~~C
// 某文件
break os.c:10
// 某函数
break _start
break main
// 汇编标签
break *0x7c00
break *0x00100010
// 查看和管理断点
info breakpoints //列出所有断点
disable 1 //禁用编号为1的断点
enable 1 //启用编号为1的断点
delete 1 //删除断点
~~~
- 断点命令示例
~~~C
break _start //在函数_start入口设置断点
run //启动程序
continue //程序运行到断点暂停
info registers //查看寄存器
x/10i $eip //查看当前指令
step // 执行下一条指令 c/c++调试
next // 执行一条源代码语句, 但是不进入函数. c/c++调试
stepi // 汇编指令级别
nexti //同上
~~~
- 查看内存命令, 是`x/<num><format> <address>`
    - `x`查看内存
    - `<num>`查看多少个单位
    - `<format>`显示格式
    - `<address>`起始地址
- 比如`x/10i $eip`和`x/16xb 0x7c00`
    - 前者, `x`是查看内存, `10`是查看10条, `i`是汇编级别, 每行一条指令, `$eip`从当前`CPU`指令指针`EIP`开始
    - 后者, `x`是查看内存, `16`是查看16个单位, `x`是以`16`进制显示, ` b`是每个单位`1`字节, `0x7c00`从地址`0x7c00`开始.

> 怎么说呢, 我编写代码, 几乎没怎么用过调试的. 所以`vscode`相关调试的配置, 我也没有了解过怎么弄. 而切, 对于`c/c++`而言, 在`vscode`中运行,配置上本身就比较复杂了, 调试的话, 我也是更不敢去碰. 不过现在呢, 通过这个, 我能明白`vscode`中的基本调试原理, 而且, 也能在`makefile`中, 自定义配置相关的`gdb`调试信息, 这样对于后续`c++`的开发, 还是十分有帮助的. 一口吃不成个大胖子, 一步一步地慢慢来, 肯定是十分有帮助的, 好吧.

- 查看`_start`的地址
~~~C
info address _start 
x/16bx _start
~~~
- 查看某寄存器的值
~~~C
print/x $bx
info registers
~~~
- 查看程序运行到哪里
~~~C
where
~~~
- 查看当前指令后面的十条指令
~~~C
x/10i $eip
~~~
- 查看`GDT`表的内容
~~~C
x/10gx &gdt_table 
// gx 表示查看64bit单元. 正好显示
~~~

















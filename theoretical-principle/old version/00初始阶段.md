@author 巷北  
@time 2025.11.29 18:18  
# 简介
这段时间, 尝试过很多新的东西, 也有了很多的理解. 关于这些理解, 其实在别的地方也写过, 这里简单提一嘴. 
- 对于编程, 新的东西(其实是库的学习, 各种语言学习是有基本的套路), 不明白源码, 不明白各个提供的接口, 最好的学习方式, 其实是复刻. 
- 所谓的复刻, 必然不是完完全全的复刻, 只需要思考, 它实现的效果是什么, 我只需要实现同样的效果即可. 
- 可能, 它有很多的效果(样式), 我选择其一, 复刻就行. 
- 典型的理解还是`neovim`, 其中有个插件, 是`nvim-tree`, 就是文件索引表. 可是, 当时我只会`lua`, `nvim`的各种接口也看不懂, 看源码的话, 架构不清晰, 逐字逐句地分析, 也并不理解. 
- 最后想了想, 不如尝试自己写一下, 这样有深的理解, 而且也没有复杂的结构. 
- 最后, 根据`ai`, 花了半个小时(忘了, 但时间也不久), 就解决了, 并借此, 更加了解`neovim`的机制了. 

有了上面的经验, 自我感觉还不错, 但其实还没有复刻操作系统的想法. 后面买了本`linux`操作系统内核解读的书, 我用了一上午, 大致翻了翻(里面有很多汇编内容, 外加操作系统的知识, 确实是看不懂, 所以只能了解一下, 这也是我一开始读它的原因), 发现, `0.12`版本的`linux`, 内核源码才两万行, 不多啊. 里面也有`linus`编写`liunx`时的状况, 比如选择了什么计算机, 怎么编写的. 另外, 之前深入学习过嵌入式, 操作系统底层跟硬件交互, 跟嵌入式有些像, 所以有了自己复刻(编写)操作系统的想法.  

但是之前的个人学习哲学是, 除了想学习的心, 还必须要有反馈. 可是编写操作系统, 什么会给我反馈呢? 一开始写的也不用太多, 只需要能显示`hello world`就行. 所以, 我`ai`了一下, 看看我的`stm32`板子, 能不能运行我的操作系统. 了解了下发现, 跟平常使用的计算机还是有区别的, 可以运行实时操作系统, 但是像`linux`操作系统就不可以. 深思熟虑之后, 打算模仿`linus`, 自己买台裸机, 运行我的操作系统, 这样能给予反馈. 可是在平台搜了搜, 没有我理想的板子, 不过有很多工控主机, 但是, 我不会弄, 担心用不长久, 也不敢买.  

后面我又想解决方案, 想到了虚拟机可以解决. 了解了一下, 发现`qemu`很不错, 我自己下载了, 在`windows`端测试, 发现不行, 总是编译不通过(代码都是`ai`的, 因为还没有学, 只能向`ai`取经). 后面转战`linux`, 也总是存在问题, 模拟不了.  

没办法, 最后搞到了些学习资料学了学, (其实配置还是不太好配置的, 因为像`C/C++`, 多文件编译问题是从来没有考虑到的)终于能稍微明白了些, 而且, 也有了反馈的效果.  
而这里呢, 是记录理解的. 因为有嵌入式学习的经验, 所以也知道, 什么时候需要强加心理表征的, 什么时候需要理解的更加深入的. 而这个文档, 就是用来整理我的心理表征的. 其实整个状态, 就是一幅图, 脑袋里随时想着这幅图即可. 而且有很多名词, 是常见的名词, 一开始不知道什么意思, 查一查, 了解一下, 见得多了, 自然也就容易明白了. 

- [启动阶段](#启动阶段)
    - [指针](#指针)

# 启动阶段
这个阶段, 会有很多汇编代码, 操作的是`cpu`内部的寄存器. 由于对`x86`架构的`cpu`并不熟悉, 也不会汇编代码, 所以这部分的理解是及其有限的, 只能简单地陈述一下基本的流程. 更加深入的理解, 害得结合后面的内容. 
- 下面是整个汇编代码
~~~ c
	#include "os.h"

	// 声明本地以下符号是全局的，在其它源文件中可以访问
	.global _start

	// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
  	.code16

	// 以下是代码区
 	.text
_start: 
	mov $0, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %ss
	mov %ax, %gs
	mov %ax, %fs
	mov $_start, %esp	
	
read_self_all:
	mov $_start_32, %bx
	mov $0x2, %cx
	mov $0x240, %ax
	mov $0x80, %dx
	int $0x13
	jc read_self_all

	jmp .
	
	.org 0x1fe
	.byte 0x55, 0xaa

_start_32:
	.fill 64*1024, 1, 0x35
~~~
- 上面的汇编代码呢, 我也确实不太懂, 这里先放过吧. 后续再说, 先谈谈`cpu`的启动状态吧.
- 通电后, 会进入"实模式"状态, 所谓的实模式, 是`x86 CPU`上电后的默认工作模式. 
- `BIOS`, 全称是`Basic Input/Output System`(基本输入输出系统). 它是固定程序(厂家自带), 初始在`flash/rom`固存内, 主要作用是在电脑开机的时候, 初始化硬件, 并将操作系统加载到内存中.  
- 具体步骤:开机->`CPU`从固定地址开始执行`BIOS`代码->`BIOS`做自检, 检查内存, 键盘, 硬盘等硬件是否正常->`BIOS`找到启动设备(硬盘/`U`盘/光盘等), 读取启动扇区(`Boot Sector`)->把启动扇区的内容加载到内存中, 然后让`CPU`开始执行其中的程序->`OS`启动.
- 启动扇区(`Boot Sector`), 就是上面给的汇编代码, `start.s`. 另外, `BIOS`找到启动设备中, 包含`U`盘一项, 其实不也就是通过`U`盘冲洗配置操作系统吗?那么, 我们自己的笔记本电脑, 操作系统代码, 或许就是在硬盘中, 启动时, 自动运行的.  
- 内存(运行内存), 是`RAM`, `CPU`本身没有很大的内存, 它的几种存储空间.
    - 寄存器(`Registers`) `CPU`内部非常小的高速存储, 用来临时保存数据和指令. 上面的`start.s`代码中, 就有将`CPU`内部寄存器初值赋为`0`的代码.
    - 缓存(`Cache`) `CPU`附近的高速缓存(`L1`, `L2`, `L3`), 比`RAM`快很多, 但容量小.
    - 主存(`RAM`) 操作系统和程序真正运行的地方, `CPU`通过总线访问.
    - `ROM/BIOS` 只读存储, 用于启动.
- 所以, `start.s`代码, 并不会被加载到`CPU`内部去运行的, 而是加载到内存中, 然后启动运行的(上面说了, `BIOS`读取启动设备(硬盘等), 读取其中的启动扇区, 并加载到内存在中).
- 扇区(Sector)是什么? 扇区是硬盘(或其他块设备)最小的存储单位. 通常一个扇区是`512`字节. 操作系统按扇区读写硬盘. 启动扇区(Boot Sector), 是硬盘的第一个扇区, 里面保存着启动程序(`start.s`). 磁盘逻辑结构式, 扇区->磁道->柱面. 记住, 扇区是硬盘上的"最小储物格", `OS`和`BIOS`都按它来读写数据.
- 上面启动文件中的各个寄存器变量名, 中断变量名, 都是固定的, `x86CPU`架构固定的, 提前定义好了的. 开机时, 这些寄存器已经存在, 但是它的值, 可能是随机的, 不过可以通过汇编指令访问修改它们. 寄存器的名字和功能是`x86`架构标准, 查`CPU`手册就能找到完整的列表.
- 在实模式下, `BIOS`通常会被映射到内存高端(例如`0xF0000-0xFFFFF`)的一段区域. `BIOS`固件在`ROM`中, 但系统会在内存地址空间里提供一段镜像给`CPU`执行. 操作系统也必须要映射到(硬盘->内存)内存中执行. 操作系统也是程序, `CPU`执行时必须在`RAM`中.
    - 流程是, `BIOS`加载`OS`的引导程序(`Bootloader`)到`RAM`
    - `Bootloader`再把操作系统内核加载到`RAM`.
    - `CPU`开始执行内核的指令.
- `Bootloader`(引导加载程序)有两个任务, 被`BIOS`加载到内存中执行, 把操作系统内核加载到`RAM`, 然后跳到内核入口执行. 而我们的`start.s`, 正在做这两件事的前一部分: 被`BIOS`加载到内存`0x7C00`, 通过`int 0x13`读取后续内容到内存. 所以, `start.s`就是`Bootloader`, 准确的来说, 是它的第一阶段. 而后一阶段, 我还没写. 不过, `Bootloader`, 是一种概念, 而`start.s`是它的具体实现. 需要搞清楚. 
## 指针
这是一个标志性的阶段. 结合上面的问题, 又问了`ai`一些问题, 现在终于理解了指针, 内存, 栈等的切实含义了. 以前写代码, 是纯软件, 缺乏硬件的理解. 可是现在, 带着硬件的思维, 再去写软件, 简直降维打击.  接下来就详细地分析一下理解吧.  
- 软件中, 所谓的地址, 永远指的是内存地址, 而不是硬件地址等, `CPU`永远也访问不了. `CPU`可以访问的只有寄存器, `RAM`(内存), `MMIO`(内存映射设备).不过, 需要注意, 我们软件端, 写的(访问的)是虚拟地址, 被操作系统映射过了. 但每一个虚拟地址, 都对应着真实的物理地址.
    - 现代`OS`(`Linux Windows Macos`)都是用虚拟内存.
    - `OS`+`MMU`(内存管理单元)把虚拟地址翻译成物理地址(真实的`RAM`位置)
- 真正的"寄存器", 只存在于`CPU`内部. 内存(`RAM`)不是寄存器, 硬盘不是寄存器, 显卡显存不是寄存器. 寄存器数量少, 速度极高, 比如:
    - `AX/BX/CX/DX`
    - `EAX/EBX/ECX/EDX`
    - `RAX/RBX/RCX`...
- 寄存器用于存放运行时数据, 参数传递, 保存临时变量, 保存地址(指针)
- 操作系统中, 将我们用户端写的程序, 加载到内存的真实布局, 由高地址到低地址, 分别是栈(`stack`),堆(`Heap`),全局,代码区(`text`).不是随便想象出来的, 是真实布局. 
- `stack`, 存储函数调用栈, `heap`存储`malloc`申请的动态内存. 全局区, 存储全局变量, `text`存储指令代码.
- 栈, 是操作系统划分的真实物理内存. `CPU`+`OS`会专门留下一段内存, 给我的程序作为栈. 比如:
~~~C
0x7fffffffe000  ← 栈顶（SP）
...
...
0x7fffffffc000  ← 栈底
~~~
- 其中, `SP`是`CPU`通过栈指针来强制实现栈的行为. 也就是说, "栈的区域"是硬件+`OS`划分出来的, 栈的特性(`LIFO`)是 `CPU`实现的. 栈不是虚构概念, 而是真实存在内存中的区域(`OS`决定), `CPU`专门用`SP/BP`寄存器操作它(硬件规则)
- 所以, 我们所谓的指针, 其实就是`CPU`内部的寄存器, 我们抽象出来的各种数据结构, 本质上, 不是虚拟的, 确实是对硬件端进行的一种合理抽象.
- 注意, 先进后出, 不是内存的特性, 而是`push/pop`的特性, 是`CPU`定义的.
- 堆(`heap`)是怎么回事? 堆和栈完全不同. 栈是`CPU`自动维护, 堆是`C`库/`OS`维护. 栈是`push/pop`自带, 堆是`malloc/free`手动. 栈是连续的, 堆不一定连续(碎片化), 栈是先进后出, 堆是任意顺序.
- 我写了如下的代码, 内存中会如何存放呢?
~~~C
int global_a = 10;

int main() {
    int local_b = 20;
    int *p = malloc(4);
}
~~~
- `main`的指令, 存放在`text`段, `global_a`存放在全局段, `local_b`存放在栈中, `p`指向了`malloc`的结果, 存放在`heap`中. 这些全部是真实的`RAM`中的物理区域.
- 之前关于指针, 搞混了, 认为`CPU`内部的寄存器就是指针, 但并不是. 指针, 只是一个"保存地址的整数", 它既可以在寄存器中, 也可以在内存中, 也可以在栈中, 也可以在堆中. 指针不是寄存器, 寄存器只是一个放"某个值"的地方. 指针是值, 寄存器是容器.
- `malloc`分配的是一块`RAM`(`heap`)中的空间. 在堆中找到空闲内存, 然后把这个地址作为"返回值"返回. 比如:
~~~C
int* p = malloc(4);
~~~
- `p`(指针变量)在哪里?寄存器?栈?堆? `p`可以在寄存器中, 也可以在内存中, 取决于编译器优化.
    - 情况一, `p`在寄存器中(优化开), `gcc`告诉优化时, 会把 `p`放在某个寄存器(如`RAX`/`RBX`)中
    - 情况二, `p`在栈中(常见)因为`p`是局部变量, 所以通常会分配在栈中.
    - 情况三, 全局(`.bss`或`.data`)
- 堆是给"被指向的数据"用的, 不是给"指针变量"用的. 指针本身, 要么在寄存器, 要么在栈, 要么在全局区. 堆只存放"数据本身".(确实. 我们在函数中, 使用`malloc`, 对于指针变量而言, 它一定不在堆中. 但是, 如果我们的数据是某个指针, 那么这个指针, 其实也可以放在堆中)
- 函数代码, 就是被编译成机器码后的指令. 如:
~~~C
int add(int a, int b) {
    return a + b;
}
~~~
- 编译后可能为:
~~~C
mov eax, edi
add eax, esi
ret
~~~
- 这些机器指令, 会放在`text`段(代码区).这是`CPU`执行的地方, `text`区是只读的, 代码就是一条条指令.
- 函数的变量+返回地址, 为什么在栈中? 调用前:
~~~C
call func
~~~
- `call`指令会:
    - `push`返回地址到栈
    - 跳到`func`的入口.
- 因此:
~~~C
Stack:
    return address   ← 必须存！call 指令自动push
~~~
- 然后, 函数里又会为局部变量分配空间:
~~~C
local variables
~~~
- 所以, 栈长这样:
~~~C
+--------------------+
|   previous frame   |
+--------------------+
|   return address   | ← call 自动 push
+--------------------+
| old RBP            |
+--------------------+
| local variable a   |
| local variable b   |
| pointer p          |
+--------------------+
~~~
- 详细一下, 比如, 我要执行`add`函数, 那么, 将该函数下一条指令地址, 先存放到栈中(`push`), 函数变量也存到栈中, 跳转执行该函数(`text`区). 该函数返回值(计算结果)放到`RAX`寄存器中. 执行`ret`指令, 从栈中`pop`返回地址并跳回. `push`和`pop`是来自计算机组成原理,`x86`指令集, 是`cpu`内部设计好的指令.

- 基本说完了, 再来补充一下吧.
    - `.bss, .data`都是存放全局变量的地方. 但前者是未初始化全局变量, 后者是初始化过的全局变量.
    - 为什么`BIOS`可以从`ROM`执行? `ROM/flash`虽然是"只读", 但它依然可以被`cpu`取指令执行. 因为`cpu`取指令=读取地址空间内容, 不管它是`RAM`还是`ROM`. `BIOS`芯片通过内存映射, 存放到`CPU`执行的地址空间. 当`CPU`执行到这里后, 就能执行其中的指令. 因此, `BIOS`不需要必须在`RAM`中. 当然, 这种映射关系是我们的`start.s`写的吗? 肯定不是啊, `BIOS`被映射到地址空间, 是主板硬件+芯片组(北桥/南桥?)在"开机前"就已经完整的事. 而且, `start.s`是`Bootloader`的第一阶段, 被`BIOS`加载后才执行.
        - `start.s`执行时刻, 是
            - `BIOS`初始化硬件之后
            - `BIOS`已经把主板内存可用信息/设备状态准备好
            - `BIOS`已经读取了引导扇区
            - `BIOS`已经把`bootloader`放到`RAM`:`0x7C00`
    - 为什么`Bootloader`必须在前`512`字节? 因为`BIOS`只读第`0`扇区(`512`字节), 并且验证末尾两个自己`0x55AA`.
